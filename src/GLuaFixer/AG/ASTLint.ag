module {GLuaFixer.AG.ASTLint}{}{}

imports
{
import GLua.AG.AST
import Text.ParserCombinators.UU.BasicInstances
import GLua.AG.Token
import qualified GLua.AG.PrettyPrint as PP
import qualified Data.Set as S
import qualified Data.Map.Strict as M
import Data.Maybe
import GLuaFixer.LintSettings

import Debug.Trace
}
include "../../GLua/AG/AST.ag"
include "../../GLua/AG/Token.ag"

----------------------------------------
--  Helper functions
----------------------------------------
{
warn :: Region -> String -> String
warn pos str = "[Warning] " ++ PP.renderRegion pos ++ ": " ++ str

-- Used in detecting "not (a == b)" kind of things
oppositeBinOp :: BinOp -> Maybe String
oppositeBinOp ALT = Just ">="
oppositeBinOp AGT = Just "<="
oppositeBinOp ALEQ = Just ">"
oppositeBinOp AGEQ = Just "<"
oppositeBinOp ANEq = Just "=="
oppositeBinOp AEq = Just "~="
oppositeBinOp _ = Nothing

-- Checks whether a variable shadows existing variables
checkShadows :: [M.Map String (Bool, Region)] -> MToken -> Maybe String
checkShadows [] _ = Nothing
checkShadows _ (MToken _ (Identifier "_")) = Nothing -- Exception for vars named '_'
checkShadows (scope : scs) mtok = if M.member lbl scope then
                                    Just $ warn (mpos mtok) ("Variable shadows existing binding of '" ++ lbl ++ "'")
                                   else
                                    checkShadows scs mtok
    where
        lbl = tokenLabel mtok

-- Registers a variable as global variable when it hasn't been
-- introduced in any of the visible scopes
registerVariable :: [M.Map String (Bool, Region)] -> Region -> String -> Bool -> [M.Map String (Bool, Region)]
registerVariable (scope : []) pos var used = [M.insert var (used, pos) scope] -- global scope
registerVariable (scope : scs) pos var used = case M.lookup var scope of
                                                Just (True, pos) -> scope : scs
                                                Just (False, pos) -> M.insert var (used, pos) scope : scs
                                                Nothing -> scope : registerVariable scs pos var used

findSelf :: [MToken] -> Bool
findSelf ((MToken _ (Identifier "self")) : _) = True
findSelf _ = False
}

----------------------------------------
--  Attributes
----------------------------------------

attr AllStuff
    inh config :: LintSettings

    inh scopeLevel :: Int
    inh loopLevel :: Int -- In how many scopes of loops we are. Used in checking labels

attr AllStuff MToken MTokenList
    chn mtokenPos :: {Region} -- The location of the warning

    chn scopes :: {[M.Map String (Bool, Region)]} -- Scopes of variables and parameters
    inh isMeta :: Bool -- whether the current piece of code is within a metafunction definition
    inh funcName :: String -- The last base function name in which a subtree exists

attr Block
    inh isRepeat :: Bool -- Scopes should not be popped and certain errors are not to be thrown when this is the body of a repeat

attr AllStuff MToken MTokenList Token TokenList Region
    syn warnings use {++} {[]} :: {[String]}
    syn copy :: self
    syn identifier use {const} {"Unknown identifier"} :: String -- identifier of the first token

attr Block MStat MStatList AReturn
    syn statementCount use {+} {1} :: Int

attr MToken
    syn mtok :: Token -- The token held by an MToken

attr Field FieldList
    chn fieldNames :: {S.Set Token} -- The field names of a table

attr UnOp
    syn isNegation :: Bool -- Whether this unop is a negation. Used in "not (a == b)" check

attr MExpr Expr PrefixExp MaybeMExpr
    inh isNegation :: Bool

attr MExpr Expr PrefixExp
    inh inParentheses :: Bool -- Whether an expression is directly between parentheses (used to check double parentheses)

attr VarsList Declaration
    inh localDefinition :: Bool

attr PrefixExp
    syn varName :: {Maybe MToken}
    syn hasSuffixes :: Bool
    inh registerVarUse :: Bool

attr FuncName
    syn isMeta :: Bool

---------------------------------------
--  Semantics
---------------------------------------
sem Token
    | Label
        lhs.identifier          = @lbl
    | Identifier
        lhs.identifier          = @ident
        +warnings               = if @ident /= "goto" then id else
                                    (:) "Don't use 'goto', it will cause a syntax error in future versions of Lua."

sem MToken
    | MToken
        lhs.mtokenPos           = @mpos.copy
        lhs.mtok                = @mtok.copy
        lhs.warnings            = map (warn @mpos.copy) @mtok.warnings

sem MTokenList MStatList MExprList FieldList VarsList
    | Cons
        lhs.mtokenPos           = @hd.mtokenPos
    | Nil

sem MStatList
    | Cons
    | Nil
        lhs.statementCount      = 0

sem MExprList
    | Cons
        hd.isNegation           = False
        hd.inParentheses        = False
    | Nil

sem MaybeMExpr
    | Just
        just.inParentheses      = True


sem Declaration
    | Tuple
        lhs.mtokenPos           = @x1.mtokenPos
        x1.isNegation           = False
        x1.registerVarUse       = False
        x1.inParentheses        = False
        x2.isNegation           = False

        loc.var                 = tokenLabel . fromJust $ @x1.varName
        loc.shadowWarning       = do
                                    var <- @x1.varName
                                    checkShadows @lhs.scopes var
        x1.scopes               = if @lhs.localDefinition then
                                    M.insert @loc.var (False, @x1.mtokenPos) (head @lhs.scopes) : tail @lhs.scopes
                                   else if isJust @x1.varName then
                                            -- non-local assignments. Register as used when a suffix of them is assigned
                                            registerVariable @lhs.scopes @x1.mtokenPos @loc.var @x1.hasSuffixes
                                        else
                                            @lhs.scopes -- ExprVar assignments don't affect the scope
        +warnings               = if not (lint_shadowing @lhs.config) || not @lhs.localDefinition || isNothing @loc.shadowWarning then id else
                                    (:) . fromJust $ @loc.shadowWarning

sem AST
    | AST
        chunk.scopes            = M.empty : @lhs.scopes
        chunk.isRepeat          = False

sem Block
    | Block
        stats.scopeLevel        = @lhs.scopeLevel + 1
        loc.maxScopeDepth       = lint_maxScopeDepth @lhs.config
        +warnings               = if @loc.maxScopeDepth == 0 || @lhs.scopeLevel /= @loc.maxScopeDepth then id else
                                    (:) $ warn @stats.mtokenPos "Are you Egyptian? What's with these fucking scope pyramids!?"
        loc.deadVars            = M.filterWithKey (\k (b, _) -> not (null k) && head k /= '_' && not b) (head @ret.scopes)
        +warnings               = if not (lint_unusedVars @lhs.config) || @lhs.isRepeat then id else
                                    (++) $ M.foldrWithKey (\k (_, pos) ls -> warn pos ("Unused variable: " ++ k) : ls) [] @loc.deadVars
        lhs.scopes              = if @lhs.isRepeat then @ret.scopes else tail @ret.scopes

sem MStat
    | MStat
        lhs.mtokenPos           = @pos.copy
        stat.mtokenPos          = @pos.copy

sem Stat
    | Def
        -- Global definitions never shadow existing bindings
        vars.localDefinition    = False
    | LocDef
        -- Local definitions might shadow existing bindings
        vars.localDefinition    = True
    | AFuncCall
        fn.isNegation           = False
        fn.registerVarUse       = True
        fn.inParentheses        = False
    | ALabel
    | ABreak
    | AContinue
    | AGoto
        +warnings               = if not (lint_gotos @lhs.config) || @lhs.loopLevel >= 2 then id else
                                    (:) $ warn @lbl.mtokenPos "Don't use labels and gotos unless you're jumping out of multiple loops."
    | ADo
        body.scopes             = M.empty : @lhs.scopes
        body.isRepeat           = False
        +warnings               = if not (lint_emptyBlocks @lhs.config) || @body.statementCount > 0 then id else
                                    (:) $ warn @lhs.mtokenPos "Empty do block"
    | AWhile
        body.loopLevel          = @lhs.loopLevel + 1
        cond.isNegation         = False
        cond.inParentheses      = False
        body.isRepeat           = False
        body.scopes             = M.empty : @cond.scopes
        +warnings               = if not (lint_emptyBlocks @lhs.config) || @body.statementCount > 0 then id else
                                    (:) $ warn @lhs.mtokenPos "Empty while loop"
    | ARepeat
        body.loopLevel          = @lhs.loopLevel + 1
        cond.isNegation         = False
        cond.inParentheses      = False
        body.isRepeat           = True
        body.scopes             = M.empty : @lhs.scopes
        lhs.scopes              = tail @cond.scopes -- Manually pop off a scope after the condition
        +warnings               = if not (lint_emptyBlocks @lhs.config) || @body.statementCount > 0 then id else
                                    (:) $ warn @lhs.mtokenPos "Empty repeat statement"
        loc.deadVars            = M.filterWithKey (\k (b, _) -> not (null k) && head k /= '_' && not b) (head @cond.scopes)
        -- +warnings               = if not (lint_unusedVars @lhs.config) then id else
         --                           (++) $ M.foldrWithKey (\k (_, pos) ls -> warn pos ("Unused variable: " ++ k) : ls) [] @loc.deadVars

    | AIf
        cond.isNegation         = False
        cond.inParentheses      = False
        body.scopes             = M.empty : @cond.scopes
        body.isRepeat           = False
        elifs.mtokenPos         = @lhs.mtokenPos
        els.mtokenPos           = @lhs.mtokenPos
        +warnings               = if not (lint_emptyBlocks @lhs.config) || @body.statementCount > 0 then id else
                                    (:) $ warn @lhs.mtokenPos "Empty if statement"
    | ANFor
        body.loopLevel          = @lhs.loopLevel + 1
        val.isNegation          = False
        val.inParentheses       = False
        to.isNegation           = False
        to.inParentheses        = False
        body.isRepeat           = False
        step.isNegation         = False
        step.inParentheses      = False
        body.scopes             = M.singleton @var.identifier (not (lint_unusedLoopVars @lhs.config), @var.mtokenPos) : @step.scopes
        loc.shadowWarning       = checkShadows @lhs.scopes @var.copy
        +warnings               = if not (lint_shadowing @lhs.config) || isNothing @loc.shadowWarning then id else
                                    (:) . fromJust $ @loc.shadowWarning
        +warnings               = if not (lint_emptyBlocks @lhs.config) || @body.statementCount > 0 then id else
                                    (:) $ warn @lhs.mtokenPos "Empty for loop"
    | AGFor
        body.loopLevel          = @lhs.loopLevel + 1
        body.isRepeat           = False
        -- The variables the for loop introduces
        loc.introduces          = M.fromList $ map (\mt -> (tokenLabel mt, (not (lint_unusedLoopVars @lhs.config), mpos mt))) @vars
        body.scopes             = @loc.introduces : @vals.scopes
        +warnings               = if not (lint_shadowing @lhs.config) then id else
                                    (++) . catMaybes . map (checkShadows @lhs.scopes) $ @vars
        +warnings               = if not (lint_emptyBlocks @lhs.config) || @body.statementCount > 0 then id else
                                    (:) $ warn @lhs.mtokenPos "Empty for loop"
    | AFunc
        loc.argIdentifiers      = filter (/= MToken emptyRg VarArg) $ @args
        body.isRepeat           = False
        loc.introduces          = (if @loc.isMeta then M.insert "self" (True, @name.mtokenPos) else id) $
                                    M.fromList . map (\mt -> (tokenLabel mt, (not . lint_unusedParameters $ @lhs.config, mpos mt))) $ @loc.argIdentifiers
        body.scopes             = @loc.introduces : (registerVariable @name.scopes @name.mtokenPos @name.identifier True)
        -- Parameter shadowing
        +warnings               = if not (lint_shadowing @lhs.config) then id else
                                    (++) . catMaybes . map (checkShadows @lhs.scopes) $ @loc.argIdentifiers
        loc.isMeta              = @name.isMeta || findSelf @args || @lhs.isMeta
        body.isMeta             = @loc.isMeta
        body.funcName           = @name.identifier
    | ALocFunc
        loc.argIdentifiers      = filter (/= MToken emptyRg VarArg) $ @args
        body.isRepeat           = False
        loc.introduces          = (if @loc.isMeta then M.insert "self" (True, @name.mtokenPos) else id) $ -- self
                                    -- parameters
                                    M.fromList . map (\mt -> (tokenLabel mt, (not . lint_unusedParameters $ @lhs.config, mpos mt))) $ @loc.argIdentifiers
        loc.funcname            = MToken @name.mtokenPos (Identifier @name.identifier)
        loc.passedScopes        = M.insert @name.identifier (False, @name.mtokenPos) (head @name.scopes) : tail @name.scopes
        body.scopes             = @loc.introduces : @loc.passedScopes
        loc.isMeta              = findSelf @args || @lhs.isMeta
        body.isMeta             = @loc.isMeta
        body.funcName           = @name.identifier
        -- Parameter shadowing
        +warnings               = if not (lint_shadowing @lhs.config) then id else
                                    (++) . catMaybes . map (checkShadows @lhs.scopes) $ @loc.argIdentifiers
        -- Function name shadowing
        loc.funcNameShadows     = checkShadows @lhs.scopes @loc.funcname
        +warnings               = if not (lint_shadowing @lhs.config) || isNothing @loc.funcNameShadows then id else
                                    (:) . fromJust $ @loc.funcNameShadows

sem ElseIf
    | Tuple
        x1.isNegation           = False
        x1.inParentheses        = False
        x2.scopes               = M.empty : @x1.scopes
        x2.isRepeat             = False
        +warnings               = if not (lint_emptyBlocks @lhs.config) || @x2.statementCount > 0 then id else
                                    (:) $ warn @lhs.mtokenPos "Empty elseif statement"

sem Else
    | Just
        just.scopes             = M.empty : @lhs.scopes
        just.isRepeat           = False
        +warnings               = if not (lint_emptyBlocks @lhs.config) || @just.statementCount > 0 then id else
                                    (:) $ warn @lhs.mtokenPos "Empty else statement"
sem AReturn
    | AReturn
        lhs.mtokenPos           = @pos.copy
    | NoReturn
        lhs.statementCount      = 0

sem FuncName
    | FuncName
        lhs.mtokenPos           = mpos (head @names)
        lhs.identifier          = tokenLabel . head $ @names
        lhs.isMeta              = isJust @meta

sem PrefixExp
    | PFVar
        lhs.mtokenPos           = @name.mtokenPos
        lhs.hasSuffixes         = not . null $ @suffixes.copy
        lhs.varName             = Just @name.copy
        -- When using variables, register them. Find out more about the global scope
        -- Also register the usage of variables when this prefixExpr is not part of a declaration
        loc.foundVars           = registerVariable @lhs.scopes @name.mtokenPos (show @name.mtok) @lhs.registerVarUse
        loc.name                = tokenLabel @name.copy
        name.scopes             = @loc.foundVars
        +warnings               = if not (lint_beginnerMistakes @lhs.config) || @lhs.isMeta || @loc.name /= "self" then id else
                                    (:) $ warn @name.mtokenPos "Don't use self in a non-metafunction"
        +warnings               = if not (lint_beginnerMistakes @lhs.config) || not @lhs.isMeta || @loc.name /= "self" ||
                                  @lhs.funcName /= "ENT" || @suffixes.identifier /= "Entity" then id else
                                    (:) $ warn @name.mtokenPos "'self.Entity' is the same as just 'self' in SENTs"
        +warnings               = if not (lint_beginnerMistakes @lhs.config) || not @lhs.isMeta || @loc.name /= "self" ||
                                  @lhs.funcName /= "SWEP" || @suffixes.identifier /= "Weapon" then id else
                                    (:) $ warn @name.mtokenPos "'self.Weapon' is the same as just 'self' in SWEPs"
    | ExprVar
        lhs.mtokenPos           = @expr.mtokenPos
        lhs.varName             = Nothing
        lhs.hasSuffixes         = False
        expr.inParentheses      = True

        +warnings               = if not (null @suffixes.copy) || not @lhs.inParentheses then id else
                                    (:) $ warn @lhs.mtokenPos "Unnecessary parentheses"

sem PFExprSuffix
    | Call
    | MetaCall
    | ExprIndex
        index.isNegation        = False
        index.inParentheses     = False
    | DotIndex

sem MExpr
    | MExpr
        lhs.mtokenPos           = @pos.copy
        expr.mtokenPos          = @pos.copy

sem Expr
    | ANil
    | AFalse
    | ATrue
    | ANumber
    | AString
    | AVarArg
    | AnonymousFunc
        loc.introduces          = M.fromList $ map (\mt -> (tokenLabel mt, (not . lint_unusedParameters $ @lhs.config, mpos mt))) @pars
        body.scopes             = @loc.introduces : @lhs.scopes
        body.isRepeat           = False
        body.isMeta             = @lhs.isMeta || findSelf @pars
        loc.argIdentifiers      = filter (/= MToken emptyRg VarArg) $ @pars
        -- Parameter shadowing
        +warnings               = if not (lint_shadowing @lhs.config) then id else
                                    (++) . catMaybes . map (checkShadows @lhs.scopes) $ @loc.argIdentifiers
    | APrefixExpr
        pexpr.registerVarUse    = True
    | ATableConstructor
        fields.fieldNames       = S.empty
    | BinOpExpr
        left.isNegation         = False
        left.inParentheses      = False
        right.isNegation        = False
        right.inParentheses     = False

        -- Wheter someone is doing "not (a == b)" or "not (a ~= b)"
        loc.stupidNegation      = oppositeBinOp @op.copy
        +warnings               = if not (lint_doubleNegations @lhs.config) || not @lhs.isNegation || isNothing @loc.stupidNegation then id else
                                    (:) $ warn @lhs.mtokenPos "Silly negation. Use '" ++ fromJust @loc.stupidNegation ++ "'"
    | UnOpExpr
        right.isNegation        = @op.isNegation
        right.inParentheses     = @op.isNegation

sem Args
    | ListArgs
    | TableArg
        arg.fieldNames          = S.empty
    | StringArg

sem Field
    | ExprField
        lhs.mtokenPos           = @key.mtokenPos
        key.isNegation          = False
        key.inParentheses       = False
        value.isNegation        = False
        value.inParentheses     = False
    | NamedField
        loc.mtokenPos           = @key.mtokenPos
        lhs.fieldNames          = S.insert @key.mtok @lhs.fieldNames
        value.isNegation        = False
        value.inParentheses     = False
        +warnings               = if not (lint_duplicateTableKeys @lhs.config) || not (S.member @key.mtok @lhs.fieldNames) then id else
                                    (:) $ warn @key.mtokenPos "Duplicate key in table: '" ++ show @key.mtok ++ "'."
    | UnnamedField
        value.isNegation        = False
        value.inParentheses     = False

sem UnOp
    | UnMinus
        lhs.isNegation          = False
    | ANot
        lhs.isNegation          = True
    | AHash
        lhs.isNegation          = False
---------------------------------------
--  Individual functions
---------------------------------------
{
inh_AST :: LintSettings -> Inh_AST
inh_AST conf = Inh_AST {
                config_Inh_AST                  = conf,
                isMeta_Inh_AST                  = False,
                loopLevel_Inh_AST               = 0,
                mtokenPos_Inh_AST               = emptyRg,
                scopeLevel_Inh_AST              = 0,
                scopes_Inh_AST                  = [M.empty],
                funcName_Inh_AST                = ""
               }

astWarnings :: LintSettings -> AST -> [String]
astWarnings conf p = warnings_Syn_AST (wrap_AST (sem_AST p) (inh_AST conf))
}
