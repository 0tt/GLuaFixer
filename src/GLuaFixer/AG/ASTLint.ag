module {GLuaFixer.AG.ASTLint}{}{}

imports
{
import GLua.AG.AST
import Text.ParserCombinators.UU.BasicInstances
import GLua.AG.Token
import qualified GLua.AG.PrettyPrint as PP
import qualified Data.Set as S
import Data.Maybe
import GLuaFixer.LintSettings

import Debug.Trace
}
include "../../GLua/AG/AST.ag"
include "../../GLua/AG/Token.ag"

----------------------------------------
--  Helper functions
----------------------------------------
{
warn :: LineColPos -> String -> String
warn pos str = "[Warning] " ++ PP.renderPos pos ++ ": " ++ str

-- Used in detecting "not (a == b)" kind of things
oppositeBinOp :: BinOp -> Maybe String
oppositeBinOp ALT = Just ">="
oppositeBinOp AGT = Just "<="
oppositeBinOp ALEQ = Just ">"
oppositeBinOp AGEQ = Just "<"
oppositeBinOp ANEq = Just "=="
oppositeBinOp AEq = Just "~="
oppositeBinOp _ = Nothing

-- Checks whether a variable shadows existing variables
checkShadows :: [S.Set String] -> MToken -> Maybe String
checkShadows [] _ = Nothing
checkShadows _ (MToken _ (Identifier "_")) = Nothing -- Exception for vars named '_'
checkShadows (scope : scs) mtok = if S.member lbl scope then
                                    Just $ warn (mpos mtok) ("Variable shadows existing binding of '" ++ lbl ++ "'")
                                   else
                                    checkShadows scs mtok
    where
        lbl = tokenLabel mtok

-- Registers a variable as global variable when it hasn't been
-- introduced in any of the visible scopes
registerVariable :: [S.Set String] -> String -> [S.Set String]
registerVariable (scope : []) var = [S.insert var scope] -- global scope
registerVariable ss@(scope : scs) var = if S.member var scope then ss else
                                        scope : registerVariable scs var

findSelf :: [MToken] -> Bool
findSelf ((MToken _ (Identifier "self")) : _) = True
findSelf _ = False
}

----------------------------------------
--  Attributes
----------------------------------------

attr AllStuff
    inh config :: LintSettings
    syn warnings use {++} {[]} :: {[String]}

    inh scopeLevel :: Int
    inh loopLevel :: Int -- In how many scopes of loops we are. Used in checking labels

attr AllStuff MToken MTokenList
    chn mtokenPos :: {LineColPos} -- The location of the warning

    chn scopes :: {[S.Set String]} -- Scopes of variables and parameters
    inh isMeta :: Bool -- whether the current piece of code is within a metafunction definition

attr AllStuff MToken MTokenList Token TokenList
    syn copy :: self
    syn identifier use {const} {"Unknown identifier"} :: String -- identifier of the first token

attr Block MStat MStatList AReturn
    syn statementCount use {+} {1} :: Int

attr MToken
    syn mtok :: Token -- The token held by an MToken

attr Field FieldList
    chn fieldNames :: {S.Set Token} -- The field names of a table

attr UnOp
    syn isNegation :: Bool -- Whether this unop is a negation. Used in "not (a == b)" check

attr MExpr Expr PrefixExp MaybeMExpr
    inh isNegation :: Bool

attr VarsList Declaration
    inh localDefinition :: Bool

attr PrefixExp
    syn varName :: {Maybe MToken}

attr FuncName
    syn isMeta :: Bool

---------------------------------------
--  Semantics
---------------------------------------
sem Token
    | Label
        lhs.identifier          = @lbl
    | Identifier
        lhs.identifier          = @ident

sem MToken
    | MToken
        lhs.mtokenPos           = @mpos
        lhs.mtok                = @mtok.copy

sem MTokenList MStatList MExprList FieldList VarsList
    | Cons
        lhs.mtokenPos           = @hd.mtokenPos
    | Nil

sem MStatList
    | Cons
    | Nil
        lhs.statementCount      = 0

sem MExprList
    | Cons
        hd.isNegation           = False
    | Nil

sem Declaration
    | Tuple
        lhs.mtokenPos           = @x1.mtokenPos
        x1.isNegation           = False
        x2.isNegation           = False

        loc.var                 = tokenLabel . fromJust $ @x1.varName
        loc.shadowWarning       = do
                                    var <- @x1.varName
                                    checkShadows @lhs.scopes var
        x1.scopes               = if @lhs.localDefinition then
                                    S.insert @loc.var (head @lhs.scopes) : tail @lhs.scopes
                                   else if isJust @x1.varName then
                                            registerVariable @lhs.scopes @loc.var -- non-local assignments
                                        else
                                            @lhs.scopes -- ExprVar assignments don't affect the scope
        +warnings               = if not (lint_shadowing @lhs.config) || not @lhs.localDefinition || isNothing @loc.shadowWarning then id else
                                    (:) . fromJust $ @loc.shadowWarning

sem AST
    | AST
        chunk.scopes            = S.empty : @lhs.scopes

sem Block
    | Block
        stats.scopeLevel        = @lhs.scopeLevel + 1
        loc.maxScopeDepth       = lint_maxScopeDepth @lhs.config
        +warnings               = if @loc.maxScopeDepth /= 0 && @lhs.scopeLevel /= @loc.maxScopeDepth then id else
                                    (:) $ warn @stats.mtokenPos "Are you Egyptian? What's with these fucking scope pyramids!?"
        lhs.scopes              = tail @stats.scopes

sem MStat
    | MStat
        lhs.mtokenPos           = @pos
        stat.mtokenPos          = @pos

sem Stat
    | Def
        -- Global definitions never shadow existing bindings
        vars.localDefinition    = False
    | LocDef
        -- Local definitions might shadow existing bindings
        vars.localDefinition    = True
    | AFuncCall
        fn.isNegation           = False
    | ALabel
    | ABreak
    | AContinue
    | AGoto
        +warnings               = if not (lint_gotos @lhs.config) || @lhs.loopLevel >= 2 then id else
                                    (:) $ warn @lbl.mtokenPos "Don't use labels and gotos unless you're jumping out of multiple loops."
    | ADo
        body.scopes             = S.empty : @lhs.scopes
        +warnings               = if not (lint_emptyBlocks @lhs.config) || @body.statementCount > 0 then id else
                                    (:) $ warn @lhs.mtokenPos "Empty do block"
    | AWhile
        body.loopLevel          = @lhs.loopLevel + 1
        cond.isNegation         = False
        body.scopes             = S.empty : @lhs.scopes
        +warnings               = if not (lint_emptyBlocks @lhs.config) || @body.statementCount > 0 then id else
                                    (:) $ warn @lhs.mtokenPos "Empty while loop"
    | ARepeat
        body.loopLevel          = @lhs.loopLevel + 1
        cond.isNegation         = False
        body.scopes             = S.empty : @lhs.scopes
        +warnings               = if not (lint_emptyBlocks @lhs.config) || @body.statementCount > 0 then id else
                                    (:) $ warn @lhs.mtokenPos "Empty repeat statement"
    | AIf
        cond.isNegation         = False
        body.scopes             = S.empty : @lhs.scopes
        elifs.mtokenPos         = @lhs.mtokenPos
        els.mtokenPos           = @lhs.mtokenPos
        +warnings               = if not (lint_emptyBlocks @lhs.config) || @body.statementCount > 0 then id else
                                    (:) $ warn @lhs.mtokenPos "Empty if statement"
    | ANFor
        body.loopLevel          = @lhs.loopLevel + 1
        val.isNegation          = False
        to.isNegation           = False
        step.isNegation         = False
        body.scopes             = S.singleton @var.identifier : @lhs.scopes
        loc.shadowWarning       = checkShadows @lhs.scopes @var.copy
        +warnings               = if not (lint_shadowing @lhs.config) || isNothing @loc.shadowWarning then id else
                                    (:) . fromJust $ @loc.shadowWarning
        +warnings               = if not (lint_emptyBlocks @lhs.config) || @body.statementCount > 0 then id else
                                    (:) $ warn @lhs.mtokenPos "Empty for loop"
    | AGFor
        body.loopLevel          = @lhs.loopLevel + 1
        -- The variables the for loop introduces
        loc.introduces          = S.fromList $ map tokenLabel @vars
        body.scopes             = @loc.introduces : @lhs.scopes
        +warnings               = if not (lint_shadowing @lhs.config) then id else
                                    (++) . catMaybes . map (checkShadows @lhs.scopes) $ @vars
        +warnings               = if not (lint_emptyBlocks @lhs.config) || @body.statementCount > 0 then id else
                                    (:) $ warn @lhs.mtokenPos "Empty for loop"
    | AFunc
        loc.argIdentifiers      = filter (/= MToken undefined VarArg) $ @args
        loc.introduces          = S.fromList . map tokenLabel $ @loc.argIdentifiers
        body.scopes             = @loc.introduces : (registerVariable @lhs.scopes @name.identifier)
        -- Parameter shadowing
        +warnings               = if not (lint_shadowing @lhs.config) then id else
                                    (++) . catMaybes . map (checkShadows @lhs.scopes) $ @loc.argIdentifiers
        body.isMeta             = @name.isMeta || findSelf @args
    | ALocFunc
        loc.argIdentifiers      = filter (/= MToken undefined VarArg) $ @args
        loc.introduces          = S.fromList . map tokenLabel $ @loc.argIdentifiers
        loc.funcname            = MToken @name.mtokenPos (Identifier @name.identifier)
        body.scopes             = @loc.introduces : @lhs.scopes
        body.isMeta             = findSelf @args
        -- Parameter shadowing
        +warnings               = if not (lint_shadowing @lhs.config) then id else
                                    (++) . catMaybes . map (checkShadows @lhs.scopes) $ @loc.argIdentifiers
        -- Function name shadowing
        loc.funcNameShadows     = checkShadows @lhs.scopes @loc.funcname
        +warnings               = if not (lint_shadowing @lhs.config) || isNothing @loc.funcNameShadows then id else
                                    (:) . fromJust $ @loc.funcNameShadows

sem ElseIf
    | Tuple
        x1.isNegation           = False
        x2.scopes               = S.empty : @lhs.scopes
        +warnings               = if not (lint_emptyBlocks @lhs.config) || @x2.statementCount > 0 then id else
                                    (:) $ warn @lhs.mtokenPos "Empty elseif statement"

sem Else
    | Just
        just.scopes             = S.empty : @lhs.scopes
        +warnings               = if not (lint_emptyBlocks @lhs.config) || @just.statementCount > 0 then id else
                                    (:) $ warn @lhs.mtokenPos "Empty else statement"
sem AReturn
    | AReturn
        lhs.mtokenPos           = @pos
    | NoReturn
        lhs.statementCount      = 0

sem FuncName
    | FuncName
        lhs.mtokenPos           = mpos (head @names)
        lhs.identifier          = tokenLabel . head $ @names
        lhs.isMeta              = isJust @meta

sem PrefixExp
    | PFVar
        lhs.mtokenPos           = @name.mtokenPos
        lhs.varName             = Just @name.copy
        -- When using variables, register them. Find out more about the global scope
        name.scopes             = registerVariable @lhs.scopes (show @name.mtok)
        +warnings               = if not (lint_beginnerMistakes @lhs.config) || @lhs.isMeta || tokenLabel @name.copy /= "self" then id else
                                    (:) $ warn @name.mtokenPos "Don't use self in a non-metafunction"
    | ExprVar
        lhs.mtokenPos           = @expr.mtokenPos
        lhs.varName             = Nothing

sem PFExprSuffix
    | Call
    | MetaCall
    | ExprIndex
        index.isNegation        = False
    | DotIndex

sem MExpr
    | MExpr
        lhs.mtokenPos           = @pos
        expr.mtokenPos          = @pos

sem Expr
    | ANil
    | AFalse
    | ATrue
    | ANumber
    | AString
    | AVarArg
    | AnonymousFunc
        loc.introduces          = S.fromList $ map tokenLabel @pars
        body.scopes             = @loc.introduces : @lhs.scopes
        body.isMeta             = @lhs.isMeta || findSelf @pars
        loc.argIdentifiers      = filter (/= MToken undefined VarArg) $ @pars
        -- Parameter shadowing
        +warnings               = if not (lint_shadowing @lhs.config) then id else
                                    (++) . catMaybes . map (checkShadows @lhs.scopes) $ @loc.argIdentifiers
    | APrefixExpr
    | ATableConstructor
        fields.fieldNames       = S.empty
    | BinOpExpr
        left.isNegation         = False
        right.isNegation        = False

        -- Wheter someone is doing "not (a == b)" or "not (a ~= b)"
        loc.stupidNegation      = oppositeBinOp @op.copy
        +warnings               = if not (lint_doubleNegations @lhs.config) || not @lhs.isNegation || isNothing @loc.stupidNegation then id else
                                    (:) $ warn @lhs.mtokenPos "Silly negation. Use '" ++ fromJust @loc.stupidNegation ++ "'"
    | UnOpExpr
        right.isNegation        = @op.isNegation

sem Args
    | ListArgs
    | TableArg
        arg.fieldNames          = S.empty
    | StringArg

sem Field
    | ExprField
        lhs.mtokenPos           = @key.mtokenPos
        key.isNegation          = False
        value.isNegation        = False
    | NamedField
        loc.mtokenPos           = @key.mtokenPos
        lhs.fieldNames          = S.insert @key.mtok @lhs.fieldNames
        value.isNegation        = False
        +warnings               = if not (lint_duplicateTableKeys @lhs.config) || not (S.member @key.mtok @lhs.fieldNames) then id else
                                    (:) $ warn @key.mtokenPos "Duplicate key in table: '" ++ show @key.mtok ++ "'."
    | UnnamedField
        value.isNegation        = False

sem UnOp
    | UnMinus
        lhs.isNegation          = False
    | ANot
        lhs.isNegation          = True
    | AHash
        lhs.isNegation          = False
---------------------------------------
--  Individual functions
---------------------------------------
{
inh_AST :: LintSettings -> Inh_AST
inh_AST conf = Inh_AST {
                config_Inh_AST                  = conf,
                isMeta_Inh_AST                  = False,
                loopLevel_Inh_AST               = 0,
                mtokenPos_Inh_AST               = LineColPos 0 0 0,
                scopeLevel_Inh_AST              = 0,
                scopes_Inh_AST                  = [S.empty]
               }

astWarnings :: LintSettings -> AST -> [String]
astWarnings conf p = warnings_Syn_AST (wrap_AST (sem_AST p) (inh_AST conf))
}
