module {GLuaFixer.AG.ASTLint}{}{}

imports
{
import GLua.AG.AST
import Text.ParserCombinators.UU.BasicInstances
import GLua.AG.Token
import qualified GLua.AG.PrettyPrint as PP
import qualified Data.Set as S
}
include "../../GLua/AG/AST.ag"
include "../../GLua/AG/Token.ag"

----------------------------------------
--  Helper functions
----------------------------------------
{
warn :: LineColPos -> String -> String
warn pos str = "[Warning] " ++ PP.renderPos pos ++ ": " ++ str
}

----------------------------------------
--  Attributes
----------------------------------------

attr AllStuff
    syn warnings use {++} {[]} :: {[String]}

    inh scopeLevel :: Int
    inh loopLevel :: Int -- In how many scopes of loops we are. Used in checking labels

attr AllStuff MToken MTokenList
    chn mtokenPos :: {LineColPos} -- The location of the warning

attr AllStuff MToken MTokenList Token TokenList
    syn copy :: self

attr MToken
    syn mtok :: Token

attr Field FieldList
    chn fieldNames :: {S.Set Token}

---------------------------------------
--  Semantics
---------------------------------------
sem MToken
    | MToken
        lhs.mtokenPos           = @mpos
        lhs.mtok                = @mtok.copy

sem MTokenList MStatList MExprList FieldList VarsList
    | Cons
        lhs.mtokenPos           = @hd.mtokenPos
    | Nil

sem Declaration
    | Tuple
        lhs.mtokenPos           = @x1.mtokenPos

sem Block
    | Block
        stats.scopeLevel        = @lhs.scopeLevel + 1
        +warnings               = if @lhs.scopeLevel /= 5 then id else
                                    (:) $ warn @stats.mtokenPos "Are you Egyptian? What's with these fucking scope pyramids!?"

sem MStat
    | MStat
        lhs.mtokenPos           = @pos

sem Stat
    | Def
    | LocDef
    | AFuncCall
    | ALabel
    | ABreak
    | AContinue
    | AGoto
        +warnings               = if @lhs.loopLevel >= 2 then id else
                                    (:) $ warn @lbl.mtokenPos "Don't use labels and gotos unless you're jumping out of multiple loops."
    | ADo
    | AWhile
        body.loopLevel          = @lhs.loopLevel + 1
    | ARepeat
    | AIf
    | ANFor
        body.loopLevel          = @lhs.loopLevel + 1
    | AGFor
        body.loopLevel          = @lhs.loopLevel + 1
    | AFunc
    | ALocFunc

sem AReturn
    | AReturn
        lhs.mtokenPos           = @pos
    | NoReturn


sem FuncName
    | FuncName
        lhs.mtokenPos           = mpos (head @names)

sem PrefixExp
    | PFVar
        lhs.mtokenPos           = @name.mtokenPos
    | ExprVar
        lhs.mtokenPos           = @expr.mtokenPos

sem MExpr
    | MExpr
        lhs.mtokenPos           = @pos

sem Expr
    | ANil
    | AFalse
    | ATrue
    | ANumber
    | AString
    | AVarArg
    | AnonymousFunc
    | APrefixExpr
    | ATableConstructor
        fields.fieldNames        = S.empty
    | BinOpExpr
    | UnOpExpr

sem Args
    | ListArgs
    | TableArg
        arg.fieldNames          = S.empty
    | StringArg

sem Field
    | ExprField
        lhs.mtokenPos           = @key.mtokenPos
    | NamedField
        loc.mtokenPos           = @key.mtokenPos
        lhs.fieldNames          = S.insert @key.mtok @lhs.fieldNames
        +warnings               = if not $ S.member @key.mtok @lhs.fieldNames then id else
                                    (:) $ warn @key.mtokenPos "Duplicate key in table: '" ++ show @key.mtok ++ "'."
    | UnnamedField

---------------------------------------
--  Individual functions
---------------------------------------
{
inh_AST = Inh_AST
            0
            (LineColPos 0 0 0)
            0

astWarnings :: AST -> [String]
astWarnings p = warnings_Syn_AST (wrap_AST (sem_AST p) inh_AST)
}
