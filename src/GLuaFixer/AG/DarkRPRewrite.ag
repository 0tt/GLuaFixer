{-# LANGUAGE ParallelListComp #-}
module {GLuaFixer.AG.DarkRPRewrite}{}{}



imports
{
import GLua.AG.AST
import GLua.TokenTypes
import Data.Maybe
import Data.List
}
include "../../GLua/AG/AST.ag"

{

identToStr :: MToken -> String
identToStr (MToken _ (Identifier s)) = s

-- All rewrites
rewriteNames = [
    "AddExtraTeam",
    "AddCustomShipment",
    "AddCustomVehicle",
    "AddEntity"
    ]

rewriteNameTo = [
    "createJob",
    "createShipment",
    "createVehicle",
    "createEntity"
    ]

rewriteFuncName i sfs = PFVar (MToken (LineColPos 0 0 0) (Identifier "DarkRP")) (funcName : sfs)
    where
        fn = rewriteNameTo !! i
        funcName = DotIndex $ MToken (LineColPos 0 0 0) (Identifier fn)

rewriteParams = [
    ["color", "model", "description", "weapons", "command", "max", "salary", "admin", "vote", "hasLicense", "NeedToChangeFrom", "customCheck"],
    ["model", "entity", "price", "amount", "separate", "pricesep", "noship", "allowed", "shipmodel", "customCheck"],
    ["name", "model", "price", "allowed", "customCheck"],
    ["entity", "model", "price", "max", "command", "allowed", "customCheck"]
    ]

-- Decides whether old syntax is used. TODO: check based on parameters.
isOldSyntax :: MToken -> Maybe Int
isOldSyntax (MToken _ (Identifier s)) = elemIndex s rewriteNames
isOldSyntax _ = Nothing

-- Extract the name of an identifier MToken
identifierName :: MToken -> String
identifierName (MToken _ (Identifier s)) = s

-- Converts syntax of jobs, shipments and entities.
-- Vehicles don't have the name as first parameter, so they're handled separately
convertSyntax :: Int -> [MExpr] -> Args
convertSyntax i (name : args) = ListArgs (name : [MExpr (LineColPos 0 0 0 ) tbl])
    where
        tbl :: Expr
        tbl = ATableConstructor [NamedField (MToken (LineColPos 0 0 0) (Identifier k)) v | (k, v) <- zip (rewriteParams !! i) args]
}

attr AllStuff
    syn repl :: self

attr PrefixExp PFExprSuffix Args ExprSuffixList
    syn args use {++} {[]} :: {[MExpr]}
    inh shouldReplace :: {Maybe Int}
    inh customItemKind :: String

sem PrefixExp
    | PFVar
        loc.isOld = isOldSyntax @name
        lhs.repl = case @loc.isOld of
                        Nothing -> PFVar @name @suffixes.repl
                        Just i -> rewriteFuncName i @suffixes.repl
        suffixes.customItemKind = identifierName @name
        suffixes.shouldReplace = @loc.isOld
    | ExprVar


sem Expr
    | APrefixExpr
        pexpr.shouldReplace = Nothing


sem Args
    | ListArgs
        lhs.repl = case @lhs.shouldReplace of
                        Nothing -> ListArgs @args.repl
                        Just i  -> if @lhs.customItemKind == "AddCustomVehicle" then
                                    TableArg [NamedField (MToken (LineColPos 0 0 0) (Identifier k)) v | (k, v) <- zip (rewriteParams !! i) @args.repl]
                                   else
                                    convertSyntax i @args.repl
        args.shouldReplace = Nothing

{
fixOldDarkRPSyntax :: AST -> AST
fixOldDarkRPSyntax p = repl_Syn_AST (wrap_AST (sem_AST p) Inh_AST)
}
