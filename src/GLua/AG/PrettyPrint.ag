module {GLua.AG.PrettyPrint}{}{}

imports
{
import GLua.AG.AST
import Text.PrettyPrint
import GLua.TokenTypes
import GLua.AG.Token
}

include "AST.ag"

{
tok :: MToken -> Doc
tok (MToken _ t) = zeroWidthText . show $ t

printList :: (a -> Doc) -> String -> [a] -> Doc
printList f sep []       = empty
printList f sep (e : es) = (f e) <> g es
    where
        g []       = empty
        g (e : es) = zeroWidthText sep <> (f e) <> g es

metaDoc :: Maybe MToken -> Doc
metaDoc (Just m) = zchr ':' <> tok m
metaDoc Nothing  = empty

printVarList :: [(PrefixExp, MExpr)] -> Doc
printVarList vars = printList pp_prefixexp ", " (map fst vars) <-> zchr '=' <-> printList pp_mexpr ", " (map snd vars)

printStats :: [MStat] -> Int -> Doc
printStats [] i = empty
printStats (x : xs) i = nest (i * 4) (pp_mstat x i) $+$ printStats xs i

printElIfs :: [(MExpr, Block)] -> Int -> Doc
printElIfs [] i = empty
printElIfs ((e, b) : es) i = zeroWidthText "elseif" <-> pp_mexpr e <-> zeroWidthText "then" $+$ pp_block b i $+$ printElIfs es i

printEls :: Maybe Block -> Int -> Doc
printEls Nothing i = empty
printEls (Just b) i = zeroWidthText "else" $+$ pp_block b i


renderPos :: LineColPos -> String
renderPos (LineColPos l c _) = "line " ++ show (succ l) ++ ", column " ++ show (succ c)

getMStatPos :: MStat -> String
getMStatPos (MStat p _) = renderPos p

getAReturnPos :: AReturn -> String
getAReturnPos (AReturn p _) = renderPos p
getAReturnPos NoReturn = "<unknown>"

getMExprPos :: MExpr -> String
getMExprPos (MExpr p _) = renderPos p

comesBefore :: LineColPos -> LineColPos -> Bool
comesBefore (LineColPos _ _ l) (LineColPos a b r) = l <= r

renderError :: Error LineColPos -> String
renderError (Inserted str pos strs)       = renderPos pos ++ ": Inserted '" ++ str ++ "'." ++ render_expecting strs
renderError (Deleted str pos strs)        = renderPos pos ++ ": Removed '" ++ str ++ "'. " ++render_expecting strs
renderError (Replaced str1 str2 pos strs) = renderPos pos ++ ": Replaced '" ++ str1 ++ "' with '" ++ str2 ++ "' at " ++ renderPos pos ++ render_expecting strs
renderError (DeletedAtEnd str)            = "Deleted '"  ++ str ++ "' at the end of the Lua file because the parser doesn't know what to do with it."

render_expecting :: [String] -> String
render_expecting [a]    = "Parser expected a " ++ a
render_expecting (a:as) = "Parser expected one of [" ++ a ++ concat (map (", " ++) as) ++ "]"
render_expecting []     = "Parser expected nothing"

infixl 5 $-$
($-$) :: Doc -> Doc -> Doc
a $-$ b = a <> zchr '\n' <> b

tnest :: Int -> Doc -> Doc
tnest i doc = sizedText 0 (replicate (i * 4) ' ') <> doc

-- Zero width char
zchr :: Char -> Doc
zchr c = zeroWidthText [c]

-- Zero width <+>
infixl 6 <->
(<->) :: Doc -> Doc -> Doc
a <-> b | a == empty = b
        | b == empty = a
        | otherwise  = a <> zchr ' ' <> b
}


attr AllStuff
    syn pretty :: Doc
    inh indent :: Int
    syn isMultiline use {||} {False} :: Bool -- whether code is printed over multiple lines

attr Declaration VarsList
    syn varPretty  use {<>} {empty}  :: Doc
    syn exprPretty use {<>} {empty}  :: Doc

attr MStatList MExprList VarsList
    inh isHead :: Bool

attr MStatList
    syn isLast use {||} {True} :: Bool

attr MStat Stat
    inh isLastStatement :: Bool

attr FieldList Field MExprList Expr MExpr PrefixExp ExprSuffixList PFExprSuffix Args Declaration VarsList
    syn multiline use {||} {False} :: Bool -- Whether a table should be printed as multiline

attr MStat MExprList MExpr
    syn pos :: LineColPos

attr MStatList MExprList FieldList Declaration VarsList ExprSuffixList ElseIf ElseIfList Else Block MStat Stat AReturn FuncName PrefixExp PFExprSuffix MExpr Expr Args Field BinOp UnOp
    chn comments :: {[MToken]}

attr FieldList
    syn isNil :: Bool

sem MStatList
    | Cons
                 lhs.isMultiline = @hd.isMultiline
                 loc.addNewline = if not @tl.isLast && (@hd.isMultiline || @tl.isMultiline) then zchr '\n' else empty
                 lhs.pretty = @loc.prettyComments $+$ @hd.pretty <> @loc.addNewline $+$ @tl.pretty
                 loc.prettyComments = foldl ($+$) empty . map tok $ @loc.commentsHere
                 loc.commentsHere = [mt | mt@(MToken pos s) <- @lhs.comments, pos `comesBefore` @hd.pos]
                 hd.comments = drop (length @loc.commentsHere) @lhs.comments
                 tl.comments = @hd.comments
                 tl.isHead  = False
                 hd.isLastStatement = @tl.isLast
                 lhs.isLast = False
    | Nil        lhs.pretty = empty

sem MStat
    | MStat      lhs.pos    = @pos

sem MExprList
    | Cons       lhs.pretty = (if @lhs.isHead then empty else zchr ',') <-> @hd.pretty <> @tl.pretty
                 tl.isHead  = False
                 lhs.pos    = @hd.pos
    | Nil        lhs.pretty = empty
                 lhs.pos    = LineColPos 0 0 0

sem FieldList
    | Cons       lhs.pretty = (@hd.pretty <> @loc.comma) `@loc.sep` @tl.pretty
                 loc.comma = if @tl.isNil then empty else zchr ','
                 loc.sep = if @loc.multiline then ($+$) else (<->)
                 loc.multiline = @hd.multiline || @tl.multiline
                 lhs.isMultiline = @loc.multiline
                 lhs.isNil  = False
    | Nil        lhs.pretty = empty
                 lhs.isNil  = True

sem Declaration
    | Tuple     lhs.varPretty = @x1.pretty
                lhs.exprPretty = @x2.pretty

sem VarsList
    | Cons      lhs.pretty = @loc.varPretty <-> zchr '=' <-> @loc.exprPretty
                loc.varPretty = (if @lhs.isHead then empty else zchr ',') <-> @hd.varPretty <> @tl.varPretty
                loc.exprPretty = (if @lhs.isHead then empty else zchr ',') <-> @hd.exprPretty <> @tl.exprPretty
                tl.isHead  = False
    | Nil       lhs.pretty = empty

sem ElseIf
    | Tuple     lhs.pretty = zeroWidthText "elseif" <-> @x1.pretty <-> zeroWidthText "then" $+$ nest 4 @x2.pretty

sem ElseIfList
    | Cons      lhs.pretty = @hd.pretty $+$ @tl.pretty
    | Nil       lhs.pretty = empty

sem Else
    | Just      lhs.pretty = zeroWidthText "else" $+$ nest 4 @just.pretty
    | Nothing   lhs.pretty = empty

sem ExprSuffixList
    | Cons       lhs.pretty = @hd.pretty <> @tl.pretty
    | Nil        lhs.pretty = empty

sem AST
    | AST       lhs.pretty = @chunk.pretty $+$ @loc.prettyComments
                loc.prettyComments = foldl ($+$) empty . map tok $ @chunk.comments
                chunk.comments = @comments

sem Block
    | Block      lhs.pretty = @stats.pretty $+$ @ret.pretty
                 stats.isHead = True

sem Stat
    | Def        lhs.pretty = @vars.pretty
                 vars.isHead = True
                 lhs.isMultiline = @vars.multiline
    | LocDef     lhs.pretty = zeroWidthText "local" <-> @vars.pretty
                 lhs.isMultiline = @vars.multiline
                 vars.isHead = True
    | AFuncCall  lhs.pretty = @fn.pretty
    | ALabel     lhs.pretty = tok @lbl
    | ABreak     lhs.pretty = zeroWidthText "break"
    | AContinue  lhs.pretty = zeroWidthText "continue"
    | AGoto      lhs.pretty = zeroWidthText "goto" <-> tok @lbl
    | ADo
                 lhs.isMultiline = True
                 lhs.pretty = zeroWidthText "do" $+$ nest 4 @body.pretty $+$ zeroWidthText "end"
                 body.indent = @lhs.indent + 1
    | AWhile     lhs.isMultiline = True
                 lhs.pretty = zeroWidthText "while" <-> @cond.pretty <-> zeroWidthText "do" $+$ nest 4 @body.pretty $+$ zeroWidthText "end"
                 body.indent = @lhs.indent + 1
    | ARepeat    lhs.pretty = zeroWidthText "repeat" $+$ nest 4 @body.pretty $+$ zeroWidthText "until" <-> @cond.pretty
                 body.indent = @lhs.indent + 1
    | AIf        lhs.isMultiline = True
                 lhs.pretty = zeroWidthText "if" <-> @cond.pretty <-> zeroWidthText "then" $+$ nest 4 @body.pretty $+$ @elifs.pretty $+$ @els.pretty $+$ zeroWidthText "end"
                 body.indent = @lhs.indent + 1
    | ANFor      lhs.isMultiline = True
                 lhs.pretty = zeroWidthText "for" <-> tok @var <-> zchr '=' <-> @val.pretty <> zchr ',' <-> @to.pretty <> zchr ',' <-> @step.pretty <-> zeroWidthText "do" $+$ nest 4 @body.pretty $+$ zeroWidthText "end"
                 body.indent = @lhs.indent + 1
    | AGFor      lhs.isMultiline = True
                 lhs.pretty = zeroWidthText "for" <-> printList tok ", " @vars <-> zeroWidthText "in" <-> @vals.pretty <-> zeroWidthText "do" $+$ nest 4 @body.pretty $+$ zeroWidthText "end"
                 body.indent = @lhs.indent + 1
                 vals.isHead = True
    | AFunc      lhs.isMultiline = True
                 lhs.pretty = zeroWidthText "function" <-> @name.pretty <> zchr '(' <> printList tok ", " @args <> zchr ')' $+$ nest 4 @body.pretty $+$ zeroWidthText "end"
                 body.indent = @lhs.indent + 1
    | ALocFunc   lhs.isMultiline = True
                 lhs.pretty = zeroWidthText "local function" <-> @name.pretty <> zchr '(' <> printList tok ", " @args <> zchr ')' $+$ nest 4 @body.pretty $+$ zeroWidthText "end"
                 body.indent = @lhs.indent + 1

sem AReturn
    | AReturn    lhs.pretty = @loc.prettyComments $+$ zeroWidthText "return" <-> @values.pretty
                 loc.prettyComments = foldl ($+$) empty . map tok $ @loc.commentsHere
                 loc.commentsHere = [mt | mt@(MToken pos s) <- @lhs.comments, pos `comesBefore` @values.pos]
                 values.comments = drop (length @loc.commentsHere) @lhs.comments
                 lhs.comments = @values.comments
                 values.isHead = True
    | NoReturn   lhs.pretty = empty

sem FuncName
    | FuncName   lhs.pretty = printList tok "." @names <> metaDoc @meta

sem PrefixExp
    | PFVar      lhs.pretty = tok @name <> @suffixes.pretty
    | ExprVar    lhs.pretty = zchr '(' <> @expr.pretty <> zchr ')' <> @suffixes.pretty

sem PFExprSuffix
    | Call       lhs.pretty = @args.pretty
    | MetaCall   lhs.pretty = zchr ':' <> tok @fn <> @args.pretty
    | ExprIndex  lhs.pretty = zchr '[' <> @index.pretty <> zchr ']'
    | DotIndex   lhs.pretty = zchr '.' <> tok @index

sem MExpr
    | MExpr             lhs.pos    = @pos

sem Expr
    | ANil              lhs.pretty = zeroWidthText "nil"
    | AFalse            lhs.pretty = zeroWidthText "false"
    | ATrue             lhs.pretty = zeroWidthText "true"
    | ANumber           lhs.pretty = zeroWidthText @num
    | AString           lhs.pretty = tok @str
    | AVarArg           lhs.pretty = zeroWidthText "..."
    | AnonymousFunc     lhs.pretty = zeroWidthText "function(" <> printList tok ", " @pars <> zeroWidthText ")" $+$ (nest 4 @body.pretty) $+$ zeroWidthText "end"
                        body.indent = 1
    | APrefixExpr       lhs.pretty = @pexpr.pretty
                        pexpr.indent = 0
    | ATableConstructor
                        lhs.pretty = if @fields.multiline then @loc.prettyMulti else @loc.prettySingle
                        loc.prettyMulti = zchr '{' $+$ nest 4 @fields.pretty $+$ zchr '}'
                        loc.prettySingle = zchr '{' <> @fields.pretty <> zchr '}'
    | BinOpExpr         lhs.pretty = @left.pretty <-> @op.pretty <-> @right.pretty
                        left.indent = 0
                        right.indent = 0
    | UnOpExpr          lhs.pretty = @op.pretty <> @right.pretty
                        right.indent = 0

sem Args
    | ListArgs  lhs.pretty = zchr '(' <> @args.pretty <> zchr ')'
                args.isHead = True
    | TableArg  lhs.pretty = if @arg.multiline then @loc.prettyMulti else @loc.prettySingle
                loc.prettyMulti = zchr '{' $+$ nest 4 @arg.pretty $+$ zchr '}'
                loc.prettySingle = zchr '{' <> @arg.pretty <> zchr '}'
    | StringArg lhs.pretty = tok @arg

sem Field
    | ExprField     lhs.pretty = zchr '[' <> @key.pretty <> zchr ']' <-> zchr '=' <-> @value.pretty
                    value.indent = 0
                    key.indent = 0
                    lhs.multiline = True
    | NamedField    lhs.pretty = tok @key <-> zchr '=' <-> @value.pretty
                    value.indent = 0
                    lhs.multiline = True
    | UnnamedField  lhs.pretty = @value.pretty
                    value.indent = 0

sem BinOp
    | APlus         lhs.pretty = zeroWidthText "+"
    | BinMinus      lhs.pretty = zeroWidthText "-"
    | AMultiply     lhs.pretty = zeroWidthText "*"
    | ADivide       lhs.pretty = zeroWidthText "/"
    | AModulus      lhs.pretty = zeroWidthText "%"
    | APower        lhs.pretty = zeroWidthText "^"
    | AConcatenate  lhs.pretty = zeroWidthText ".."
    | ALT           lhs.pretty = zeroWidthText "<"
    | ALEQ          lhs.pretty = zeroWidthText "<="
    | AGT           lhs.pretty = zeroWidthText ">"
    | AGEQ          lhs.pretty = zeroWidthText ">="
    | AEq           lhs.pretty = zeroWidthText "=="
    | ANEq          lhs.pretty = zeroWidthText "~="
    | AAnd          lhs.pretty = zeroWidthText "and"
    | AOr           lhs.pretty = zeroWidthText "or"

sem UnOp
    | UnMinus  lhs.pretty = zeroWidthText "-"
    | ANot     lhs.pretty = zeroWidthText "not "
    | AHash    lhs.pretty = zeroWidthText "#"

{

pp_block :: Block -> Int -> Doc
pp_block p i = pretty_Syn_Block (wrap_Block (sem_Block p) (Inh_Block [] i))

pp_mstat :: MStat -> Int -> Doc
pp_mstat p i = pretty_Syn_MStat (wrap_MStat (sem_MStat p) (Inh_MStat [] i False))

pp_prefixexp :: PrefixExp -> Doc
pp_prefixexp p = pretty_Syn_PrefixExp (wrap_PrefixExp (sem_PrefixExp p) (Inh_PrefixExp [] 0))

pp_pfexprsuffix :: PFExprSuffix -> Doc
pp_pfexprsuffix p = pretty_Syn_PFExprSuffix (wrap_PFExprSuffix (sem_PFExprSuffix p) (Inh_PFExprSuffix [] 0))

pp_field :: Field -> Doc
pp_field p = pretty_Syn_Field (wrap_Field (sem_Field p) (Inh_Field [] 0))

pp_mexpr :: MExpr -> Doc
pp_mexpr p = pretty_Syn_MExpr (wrap_MExpr (sem_MExpr p) (Inh_MExpr [] 0))

prettyprint :: AST -> String
prettyprint p = render $ pretty_Syn_AST (wrap_AST (sem_AST p) (Inh_AST 0))

renderBlock        :: Block -> String
renderBlock p      = render $ pretty_Syn_Block (wrap_Block (sem_Block p) (Inh_Block [] 0))

renderStat         :: Stat -> String
renderStat p       = render $ pretty_Syn_Stat (wrap_Stat (sem_Stat p) (Inh_Stat [] 0 False))

renderMStat         :: MStat -> String
renderMStat p       = render $ pretty_Syn_MStat (wrap_MStat (sem_MStat p) (Inh_MStat [] 0 False))

renderAReturn      :: AReturn -> String
renderAReturn p    = render $ pretty_Syn_AReturn (wrap_AReturn (sem_AReturn p) (Inh_AReturn [] 0))

renderFuncName     :: FuncName -> String
renderFuncName p   = render $ pretty_Syn_FuncName (wrap_FuncName (sem_FuncName p) (Inh_FuncName [] 0))

renderPrefixExp    :: PrefixExp -> String
renderPrefixExp p  = render $ pretty_Syn_PrefixExp (wrap_PrefixExp (sem_PrefixExp p) (Inh_PrefixExp [] 0))

renderExpr         :: Expr -> String
renderExpr p       = render $ pretty_Syn_Expr (wrap_Expr (sem_Expr p) (Inh_Expr [] 0))

renderMExpr         :: MExpr -> String
renderMExpr p       = render $ pretty_Syn_MExpr (wrap_MExpr (sem_MExpr p) (Inh_MExpr [] 0))

renderArgs         :: Args -> String
renderArgs p       = render $ pretty_Syn_Args (wrap_Args (sem_Args p) (Inh_Args [] 0))

renderField        :: Field -> String
renderField p      = render $ pretty_Syn_Field (wrap_Field (sem_Field p) (Inh_Field [] 0))

}
